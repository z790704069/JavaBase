
## 设计

* 设计工作
> 无论软件工程中的哪一个步骤，工作的开展都是为了解决一些实际问题

> 架构设计、子系统设计、功能模块设计，甚至类的设计，这些都是设计工作。

* 原则
> 设计工作的开展是在一定的环境下进行，有很多的耳熟能详的规范或者原则（可扩展、高可用、高性能）。个人经历有限，自认为评判设计工作是否开展合理的重要一点是合适性。这甚至可以作为设计工作开展的准则，为什么这么说呢：因为设计是为了解决实际问题，同时为后面的编码工作提供一种行为标准和指导。

* 需要灵活？
> 对于技术框架和工具的选择没有必要进行严格的限定，技术方法和手段并不是关键，关键是对问题的抽象与复杂度分解。

> 环境背景不同，设计完全可以是不同。比如设计一个并发只有数百并发的web系统（当然这个是基于现在以及中长期预测的判断），在数据层就没有必要进行细粒度的拆分，减少不必要的分布式带来的复杂度工作。但是，如果你的系统一出生就是针对海量的客户以及并发，那一开始就需要把高并发带来的复杂度考虑进去。

* 基础
> 设计工作需要多方面的知识和经验储备：比如丰富的架构知识，丰富的业务经验，对业务复杂度提升以及系统用户规模增长的理解

* 协作
> 设计工作不是一个人的事情，需要达成共识，如果因为种种因素无法达成一个共同的方向（这些因素可能包括：不同人对问题的理解相左、对未来业务的发展与规划见解不同、人员技能各异、个人情感喜好），那后面的工作开展起来也不会很顺利。

## 编码

* 指导意见
> 编码首先需要关注是否在整体设计框架下进行（如果真的有进行设计^^,并且已经达成共识。为什么这么说，因为确实有不少工程是没有进行设计过的，开发人员追求进度或者不重视设计）

* 重构
> 过去总是那么的不堪：要有一个谦卑的意识，即使你之前的代码写的多好多清晰多有设计感多么艺术，现在看来它都应该是不美好的（大多时候不需要谦卑，因为他们本来就很糟糕）。如果你有时间，不妨去改造它。但是这个开展起来很难，因为你可能没有时间，或者你当心这种改造可能带来难以想象的麻烦，或者你觉得这个不能收到及时的效果不被领导认可。

* 一些偏见
> 对于编码工作存在一些考量的不公平，有些公司忽视对技术的演技以及看不见的优化，然而这其实是基础。企业想在技术上脱颖而出并通过此实现竞争力达到利益持久化，应该关注并重视技术，包括人才的重视并且需要提供足够的耐心与时间来培养人。

* 目标
> 与设计一样，编码的目标也是为了解决实际问题。这个观点要一直牢记在心。为什么这么说：设计将问题进行大维度的分解，产出可能是各个子系统或者系统中各个子模块，以及这些子系统、子模块之间联系（高内聚、低耦合）。而编码，则是问题的进一步细化，遵循设计的原则以及达到设计目标。

* 根基很重要
> 信息化方案是一套借助计算机器解决实际问题的方法和手段，方案的主体是人（AI能解决一些问题，但是最终也是由人来创造并为人服务）。编程语言是一套方法与工具的集合，连接人类与计算机器，因为机器不懂人话，它只懂二进制。编程语言就是提供一种人类易于操作计算机器的方法，想好更好的控制计算机器达成自己的目的，开发者需要按照语法的套路进行编写程序。

> 当你明白编程的大道理并且深入理解它，你就能成为更好的开发者，并且乐此不疲。

> 软件工程领域的知识、框架很多，他们提供开发者以便利。我们需要根据需要去学习掌握它们。但我们也一定要知道万变不离其宗的道理，这里说的是对于基础的掌握，这会让你知其然知其所以然。

> 坚持自己的理解，但是也许别人的思路也是对的，只不过你站的角度不同，或者此时的你没有思考到。需要讨论，激发出更多的可能性。

* 快乐编程吧？
> 编程可以是快乐的，也可以是枯燥的。如果你保持对知识的敬畏之心，觉得探索是一种乐趣，编程应该是快乐的，以为它本身就是一个需要不断探索巩固的知识领域。当然，有时我们也会觉得枯燥（生存），因为生活不是单一的，我们还需要经历很多其他的事情与烦恼。生活需要专注，需要乐观，需要享受，需要解决烦恼，需要释怀包容。

## 一些零碎知识

> 所谓零碎知识，当然......可以不用排版^^

* 类型相似度

对象内存
对象应用



* 访问控制
所有的优秀作者，包括那些编写软件的程序员，都清楚其著作的某些部分直至重新创作的时候才变得完美，有时候甚至反复重写多次。面向对象设计中需要考虑的一个基本问题：“如何把变动的事物与保持不变的事物区分开来”

* 复用
使用现有类来生成新类：组合 & 继承 & 代理

* 组合
* 继承

> 基类的构造器在导出类之后，这对无参的构造方法，或者默认构造方法（没有为类特别设置构造方法的情况下）

> 如果没有默认构造方法，或者想调用带有参数的基类构造方法，需要使用关键字super显式调用基类构造方法

* 多态
> 不能使用子类特有的成员属性和子类特有的成员方法

* 代理
静态代理
动态代理(反射)

* 反射？
反射

> 在Java运行时环境中，对于任意一个类，可以知道这个类有哪些属性和方法。对于任意一个对象，可以调用它的任意一个方法。这种动态获取类的信息以及动态调用对象的方法的功能来自于Java 语言的反射（Reflection）机制。

Java 反射机制主要提供了以下功能

> 在运行时判断任意一个对象所属的类。
在运行时构造任意一个类的对象。
在运行时判断任意一个类所具有的成员变量和方法。
在运行时调用任意一个对象的方法

* IOC/DI

* 向上转型

* final关键字
处于设计或者效率考虑
> 基础数据：数据恒定部标
> 对象：对象的引用恒定不变，但无法保证引用的对象的值不发生改变。（对象的引用和对象本身不是一个改变）

final修饰对象
final方法
final类

* javac vs JIT

![IMAGE](quiver-image-url/489F0F449719817454C2D37658747885.jpg =553x238)


* 语法糖

Java泛型以及类型推断


